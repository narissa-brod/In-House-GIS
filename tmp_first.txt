<script setup lang="ts">
import { onMounted, ref, watch } from 'vue';
import { GoogleMapsOverlay } from '@deck.gl/google-maps';
import { GeoJsonLayer } from '@deck.gl/layers';
import { MVTLayer } from '@deck.gl/geo-layers';
import { createClient } from '@supabase/supabase-js';

// Type definitions

type ParcelRow = {
  id: number;
  apn: string | null;
  address: string | null;
  city: string | null;
  zip_code: string | null;
  county: string | null;
  owner_type: string | null; // Now contains owner name
  owner_name?: string | null;
  owner_address?: string | null;
  size_acres: number | null;
  property_url: string | null;
  property_value?: number | null;
  subdivision?: string | null;
  year_built?: number | null;
  sqft?: number | null;
  geojson: { type: 'Polygon' | 'MultiPolygon'; coordinates: any };
};

declare global {
  interface Window {
    pmtiles: any;
  }
}

// Props include Airtable records (id + fields)
const props = defineProps<{ rows: Array<{ id: string; fields: Record<string, any> }> }>();

// Refs
const mapEl = ref<HTMLDivElement | null>(null);
const map = ref<google.maps.Map | null>(null);
const markers: google.maps.Marker[] = [];
const polygons: google.maps.Polygon[] = [];
const polygonsByApn: Record<string, google.maps.Polygon> = {}; // Track polygons by APN
const markersById: Record<string, google.maps.Marker> = {};
const infoWindowsById: Record<string, google.maps.InfoWindow> = {};
let geocoder: google.maps.Geocoder | null = null;
const cache = new Map<string, google.maps.LatLngLiteral>();
let currentInfoWindow: google.maps.InfoWindow | null = null; // Track currently open info window
let deckOverlay: GoogleMapsOverlay | null = null; // deck.gl overlay for parcels
const showParcels = ref(false); // Toggle for parcel layer (start disabled)
const showCounties = ref(true); // Toggle for county boundaries layer (start enabled)
const showAirtableMarkers = ref(true); // Toggle for Airtable markers (start enabled)
const showGeneralPlan = ref(false); // Toggle for General Plan layer (static GeoJSON)
const countyPolygons: google.maps.Polygon[] = []; // Store county boundary polygons
const countyLabels: google.maps.Marker[] = []; // Store county name labels


// Airtable IDs from .env
const AIRTABLE_BASE = import.meta.env.VITE_AIRTABLE_BASE as string;
const AIRTABLE_TABLE_ID = import.meta.env.VITE_AIRTABLE_TABLE_ID as string;
const AIRTABLE_VIEW_ID = import.meta.env.VITE_AIRTABLE_VIEW_ID as (string | undefined);
const AIRTABLE_API_KEY = import.meta.env.VITE_AIRTABLE_TOKEN as string;

// Landowner Airtable Config (new)
const AIRTABLE_LANDOWNER_BASE = import.meta.env.VITE_AIRTABLE_LANDOWNER_BASE as string;
const AIRTABLE_LANDOWNER_TABLE_ID = import.meta.env.VITE_AIRTABLE_LANDOWNER_TABLE_ID as string;

// Vector Tiles URL - for low/medium zoom levels
// For local dev: serve tiles directory via Vite public folder or separate server
// For production: upload to CDN (S3/R2/Cloudflare) and version the URL
const PARCELS_TILES_URL = (import.meta.env.VITE_PARCELS_TILES_URL as string) || '/tiles/{z}/{x}/{y}.pbf';
// Optional static General Plan GeoJSON served from /public
const GP_STATIC_URL = (import.meta.env.VITE_GP_STATIC_URL as string | undefined);

function createGeneralPlanStaticLayer() {
  if (!GP_STATIC_URL) return null;
  return new GeoJsonLayer({
    id: 'general-plan-static',
    data: GP_STATIC_URL,
    filled: true,
    getFillColor: (f: any) => {
      const z = (f.properties?.zone_type || '').toString().toLowerCase();
      const colors: Record<string, [number, number, number, number]> = {
        'single family residential': [247, 228, 91, 120],
        'multifamily residential':   [255, 128, 128, 120],
        'commercial':                [255, 64, 64, 120],
        'parks':                     [120, 200, 120, 120],
        'parks/open space':          [120, 200, 120, 120],
        'open space':                [120, 200, 120, 120]
      };
      return colors[z] || [180, 180, 180, 90];
    },
    stroked: true,
    getLineColor: [40, 40, 40, 180],
    lineWidthMinPixels: 1,
    pickable: true,
  });
}

// Add parcel to Airtable (Land Database table)
async function addParcelToAirtable(parcel: ParcelRow) {
  try {
    // Build mailing address string
    const mailingParts = [
      parcel.owner_address,
      parcel.city,
      'UT',
      parcel.zip_code
    ].filter(Boolean);
    const mailingAddress = mailingParts.join(', ');

    // Start with minimal required fields only
    // Use property address for Name, fallback to "Parcel {APN}" only if no address
    const payload = {
      fields: {
        'Name': parcel.address || `Parcel ${parcel.apn || 'Unknown'}`
      }
    };

    // Add optional fields (only works if they're text fields in Airtable, not dropdowns)
    const optionalFields: Record<string, any> = {
      'Property Address': parcel.address,
      'Parcel(s)': parcel.apn,
      'Size (acres)': parcel.size_acres,
      'ZIP': parcel.zip_code,
      'Owner Name': parcel.owner_name,
      'Mailing Address': mailingAddress,
      'City': parcel.city  // Only works if City is a text field, not dropdown
    };

    // Only add fields that exist and have values
    for (const [key, value] of Object.entries(optionalFields)) {
      if (value) {
        (payload.fields as any)[key] = value;
      }
    }

    console.log('Sending to Airtable:', payload);

    // Use table ID instead of table name to avoid encoding issues
    console.log('Using table ID:', AIRTABLE_TABLE_ID);

    const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE}/${AIRTABLE_TABLE_ID}`, {
      method: 'POST',    
      headers: {
        'Authorization': `Bearer ${AIRTABLE_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    })

    const responseData = await response.json();
    console.log('Airtable response:', responseData);

    if (!response.ok) {
      console.error('Airtable API error:', responseData);
      alert(`Failed to add to Airtable:\n\n${JSON.stringify(responseData, null, 2)}\n\nCheck console for full details.`);
      return false;
    }

    console.log('Added to Airtable:', responseData);

    // Build URL to open the newly created record in Airtable
    const recordId = responseData.id;
    const recordUrl = AIRTABLE_VIEW_ID
      ? `https://airtable.com/${AIRTABLE_BASE}/${AIRTABLE_TABLE_ID}/${AIRTABLE_VIEW_ID}/${recordId}`
      : `https://airtable.com/${AIRTABLE_BASE}/${AIRTABLE_TABLE_ID}/${recordId}`;

    // Open Airtable record in new tab
    window.open(recordUrl, '_blank');

    return true;
  } catch (error) {
    console.error('Failed to add to Airtable:', error);
    alert(`Failed to add to Airtable: ${error}\n\nCheck console for details.`);
    return false;
  }
}

//Add parcel to Airtable (LandOwner Database table)
async function addParcelToLandownerAirtable(parcel: ParcelRow) {
  try {
    // Build mailing address string
    const mailingParts = [
      parcel.owner_address,
      parcel.city,
      'UT',
      parcel.zip_code
    ].filter(Boolean);
    const mailingAddress = mailingParts.join(', ');

    const payload = {
      fields: {
        'Name': parcel.owner_name
      }
    };

    const optionalFields: Record<string, any> = {
      'Owner Address': mailingAddress,
      'City': parcel.city  // Only works if City is a text field, not dropdown
    };

    // Only add fields that exist and have values   
    for (const [key, value] of Object.entries(optionalFields)) {
      if (value) {
        (payload.fields as any)[key] = value;
      }
    }

    console.log('Sending to Airtable:', payload);

    const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_LANDOWNER_BASE}/${AIRTABLE_LANDOWNER_TABLE_ID}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${AIRTABLE_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    })

    const responseData = await response.json();
    console.log('Airtable response:', responseData);

    if (!response.ok) {
      console.error('Airtable API error:', responseData);
      alert(`Failed to add to Airtable:\n\n${JSON.stringify(responseData, null, 2)}\n\nCheck console for full details.`);
      return false;
    }

    console.log('Added to Airtable:', responseData);
    const recordId = responseData.id;

    const recordUrl = `https://airtable.com/${AIRTABLE_LANDOWNER_BASE}/${AIRTABLE_LANDOWNER_TABLE_ID}/${recordId}`

    // Open Airtable record in new tab
    window.open(recordUrl, '_blank');

    return true;
  } catch (error) {
    console.error('Failed to add to Airtable:', error);
    alert(`Failed to add to Airtable: ${error}\n\nCheck console for details.`);
    return false;
  }
}

// Load Google Maps API
async function loadGoogleMaps(key: string, libraries: string[] = ['places']): Promise<void> {
  return new Promise<void>((resolve, reject) => {
    if ((window as any).google?.maps) return resolve();
    const existing = document.querySelector<HTMLScriptElement>('script[data-google-maps-loader]');
    if (existing) {
      existing.addEventListener('load', () => resolve());
      existing.addEventListener('error', () => reject(new Error('Google Maps failed to load')));
      return;
    }
    const s = document.createElement('script');
    s.dataset.googleMapsLoader = '1';
    const libs = libraries.length ? `&libraries=${libraries.join(',')}` : '';
    s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}&v=weekly${libs}`;
    s.async = true;
    s.defer = true; 
    s.onload = () => resolve();
    s.onerror = () => reject(new Error('Google Maps failed to load'));
    document.head.appendChild(s);
  });
}

// Initialize Supabase client
const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL as string,
  import.meta.env.VITE_SUPABASE_ANON_KEY as string
);

// Initialize map
async function ensureMap() {
  const key = import.meta.env.VITE_GOOGLE_MAPS_KEY as string;
  if (!key) {
    console.error('Missing VITE_GOOGLE_MAPS_KEY in .env');
    return;
  }

  try {
    await loadGoogleMaps(key);
    if (!mapEl.value) return;

    // It's possible that google.maps is still undefined immediately after loading.
    // A short delay might be necessary.
    await new Promise(resolve => setTimeout(resolve, 50));
    map.value = new google.maps.Map(mapEl.value, { // use ! here
      center: { lat: 40.7608, lng: -111.8910 },
      zoom: 10,
      streetViewControl: false,
      fullscreenControl: false,
      mapTypeControl: true, // Re-enable default map type controls
    });
    geocoder = new google.maps.Geocoder();

    // Initialize deck.gl overlay
    await initializeDeckOverlay();

  } catch (error) {
    console.error('Failed to initialize Google Maps:', error);
  }
}

// Initialize deck.gl overlay for GPU-accelerated parcel rendering
async function initializeDeckOverlay() {
  if (!map.value) return;

  // Create the overlay
  deckOverlay = new GoogleMapsOverlay({
    layers: []
  });

  // Attach to Google Maps
  deckOverlay.setMap(map.value);

  console.log('Gï¿½ï¿½ deck.gl overlay initialized');
}

// On-click handler for both tile and GeoJSON layers
async function handlePick({ apn, coordinate, props }: { apn: string, coordinate: [number, number], props: any }) {
  if (!map.value || !apn) return;

  // Immediately show info window with properties from the clicked feature (tile or GeoJSON)
  if (currentInfoWindow) {
    currentInfoWindow.close();
  }

  // Fetch full, live details from Supabase using the new RPC function
  const { data: fullParcel, error } = await supabase.rpc('parcel_by_apn', { apn_in: apn });

  if (error) {
    console.error('Error fetching full parcel details:', error);
    // Even if the fetch fails, we can still show the basic info from the tile/feature
  }

  // Combine properties: start with tile/feature props, then overwrite with fresh data from DB
  const finalProps = { ...props, ...(fullParcel || {}) };

  // Create and show the InfoWindow
  const html = createStyledParcelInfoWindowHtml(finalProps as ParcelRow);
  currentInfoWindow = new google.maps.InfoWindow({
    content: html,
    position: { lat: coordinate[1], lng: coordinate[0] },
  });

  // Close popup when user clicks the X
  currentInfoWindow.addListener('closeclick', () => {
    currentInfoWindow = null;
  });

  currentInfoWindow.open({ map: map.value });

  // Add event listeners for the buttons inside the InfoWindow
  google.maps.event.addListenerOnce(currentInfoWindow, 'domready', () => {
    const buttonId = `add-to-airtable-deck-${finalProps.id}`;
    const landownerButtonId = `add-to-landowner-airtable-deck-${finalProps.id}`;
    
    const button = document.getElementById(buttonId);
    if (button) {
      button.addEventListener('click', () => addParcelToAirtable(finalProps as ParcelRow));
    }

    const landownerButton = document.getElementById(landownerButtonId);
    if (landownerButton) {
      landownerButton.addEventListener('click', () => addParcelToLandownerAirtable(finalProps as ParcelRow));
    }
    const toggleId = `toggle-details-${finalProps.id}`;
    const detailsId = `details-${finalProps.id}`;
    const toggleEl = document.getElementById(toggleId) as HTMLAnchorElement | null;
    if (toggleEl) {
      toggleEl.addEventListener('click', (e) => {
        e.preventDefault();
        const d = document.getElementById(detailsId) as HTMLDivElement | null;
        if (d) {
          const show = d.style.display !== 'none';
          d.style.display = show ? 'none' : 'block';
          toggleEl.textContent = show ? 'Gï¿½+ Show More Details' : 'Gï¿½ï¿½ Hide Details';
        }
      });
    }
    // ... any other button listeners ...
  });
}

// Build HTML content for parcel info window (deck.gl click)
function createParcelInfoWindowHtml(p: ParcelRow): string {
  const title = p.address || (p.apn ? `Parcel ${p.apn}` : 'Parcel');
  const idSafe = p.id ?? 'x';

  const sublineParts: string[] = [];
  if (p.city) sublineParts.push(String(p.city));
  if (p.zip_code) sublineParts.push(String(p.zip_code));
  const subline = sublineParts.join(' ');

  const sizeText = p.size_acres != null ? `${Number(p.size_acres).toFixed(2)} ac` : 'Gï¿½ï¿½';
  const countyText = p.county ?? 'Gï¿½ï¿½';

  const airtableBtnId = `add-to-airtable-deck-${idSafe}`;
  const landownerBtnId = `add-to-landowner-airtable-deck-${idSafe}`;

  const propertyLink = p.property_url
    ? `<div style=\"margin-top:1rem; padding-top:1rem; border-top:1px solid #e5e7eb; text-align:center;\">
         <a href=\"${p.property_url}\" target=\"_blank\" rel=\"noopener\" style=\"color:#2563eb; text-decoration:none; font-size:0.9375rem;\">Open Property Page Gï¿½ï¿½</a>
       </div>`
    : '';

  return `
    <div style=\"min-width:21.25rem; line-height:1.8; font-size:1rem; font-family: system-ui, -apple-system, sans-serif; font-weight:600; padding:0.5rem;\">
      <div style=\"font-size:0.8125rem; color:#dc2626; text-transform:uppercase; letter-spacing:0.03125rem; margin-bottom:0.75rem; text-align:center;\">Parcel</div>
      <div style=\"font-size:1.25rem; color:#1f2937; margin-bottom:0.5rem; text-align:center;\">${title}</div>
      <div style=\"font-size:0.9375rem; color:#6b7280; margin-bottom:1rem; text-align:center;\">${subline}</div>
      <div style=\"display:flex; gap:1.25rem; margin-bottom:0.5rem; font-size:1rem; justify-content:center;\">
        <div><span style=\"color:#6b7280;\">Size:</span> ${sizeText}</div>
        <div><span style=\"color:#6b7280;\">County:</span> ${countyText}</div>
      </div>
      <div style=\"display:flex; gap:0.5rem; justify-content:center; margin:0.75rem 0;\">
        <button id=\"${airtableBtnId}\" style=\"background:#2563eb; color:white; border:none; border-radius:6px; padding:0.5rem 0.75rem; cursor:pointer; font-weight:600;\">Add to Land DB</button>
        <button id=\"${landownerBtnId}\" style=\"background:#111827; color:white; border:none; border-radius:6px; padding:0.5rem 0.75rem; cursor:pointer; font-weight:600;\">Add Owner</button>
      </div>
      ${propertyLink}
    </div>
  `;
}

// New styled popup matching provided mockup
function createStyledParcelInfoWindowHtml(p: ParcelRow): string {
  const title = (p.address || '').toString().toUpperCase() || (p.apn ? `PARCEL ${p.apn}` : 'PARCEL');
  const idSafe = p.id ?? 'x';

  const countyText = (p.county || '').toString() + ' County';
  const sizeText = p.size_acres != null ? `${Number(p.size_acres).toFixed(2)} acres` : 'Gï¿½ï¿½';
  const apnText = p.apn || 'Gï¿½ï¿½';
  const ownerName = (p.owner_name || '').toString().toUpperCase();
  const ownerAddr1 = (p.owner_address || '').toString().toUpperCase();
  const ownerAddr2 = [p.city, p.zip_code].filter(Boolean).join(', ').toUpperCase();

  const airtableBtnId = `add-to-airtable-deck-${idSafe}`;
  const landownerBtnId = `add-to-landowner-airtable-deck-${idSafe}`;

  const viewLink = p.property_url
    ? `<a href="${p.property_url}" target="_blank" rel="noopener" style="color:#2563eb; text-decoration:none; font-size:0.875rem;">View on Utah Parcels Gï¿½ï¿½</a>`
    : '';
  const countySearch = countyText
    ? `<a href="https://www.google.com/search?q=${encodeURIComponent(countyText + ' parcel search ' + (p.apn||''))}" target="_blank" rel="noopener" style="color:#6b7280; text-decoration:none; font-size:0.875rem;">Search ${countyText} Gï¿½ï¿½</a>`
    : '';

  // Build all details section
  const detailsRows: string[] = [];
  if (p.subdivision) detailsRows.push(`<div style="margin:0.375rem 0; color:#6b7280; font-weight:600;">Subdivision: ${String(p.subdivision)}</div>`);
  if (p.year_built) detailsRows.push(`<div style="margin:0.375rem 0; color:#6b7280; font-weight:600;">Year Built: ${String(p.year_built)}</div>`);
  if (p.sqft) detailsRows.push(`<div style="margin:0.375rem 0; color:#6b7280; font-weight:600;">Building Sq Ft: ${String(p.sqft).toLocaleString()}</div>`);
  if (p.property_value) detailsRows.push(`<div style="margin:0.375rem 0; color:#6b7280; font-weight:600;">Property Value: $${Number(p.property_value).toLocaleString()}</div>`);
  if (p.owner_type) detailsRows.push(`<div style="margin:0.375rem 0; color:#6b7280; font-weight:600;">Owner Type: ${String(p.owner_type)}</div>`);

  return `
    <div style="min-width:23rem; max-width:26rem; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color:#111827; padding:0.5rem; user-select: none; -webkit-user-select: none; -moz-user-select: none;">
      <!-- Header with icon and county name -->
      <div style="text-align:center; font-size:0.75rem; font-weight:700; color:#2563eb; text-transform:uppercase; letter-spacing:0.05rem; margin-bottom:0.75rem;">
        <svg width="12" height="12" viewBox="0 0 12 12" style="display:inline-block; vertical-align:middle; margin-right:0.25rem; margin-bottom:0.125rem;">
          <path d="M6 0 L12 6 L6 12 L0 6 Z" fill="#2563eb"/>
        </svg>
        <span style="color:#2563eb;">${countyText.toUpperCase()} PARCEL</span>
      </div>

      <!-- Property Address -->
      <div style="text-align:center; font-size:1.375rem; font-weight:600; letter-spacing:-0.01rem; line-height:1.3; margin-bottom:0.5rem;">${title}</div>

      <!-- County -->
      <div style="text-align:center; font-size:0.9375rem; color:#6b7280; font-weight:600; margin-bottom:1.25rem;">${countyText}</div>

      <!-- Owner Information Section -->
      <div style="background:#f9fafb; border-radius:8px; padding:1rem; margin-bottom:1.25rem;">
        <div style="text-align:center; font-size:0.6875rem; color:#6b7280; font-weight:700; letter-spacing:0.05rem; margin-bottom:0.75rem;">OWNER INFORMATION</div>
        ${ownerName ? `<div style="text-align:center; font-size:0.9375rem; font-weight:600; margin-bottom:0.375rem; color:#111827; line-height:1.4;">${ownerName}</div>` : ''}
        ${ownerAddr1 ? `<div style="text-align:center; font-size:0.875rem; color:#6b7280; font-weight:600; line-height:1.4;">${ownerAddr1}</div>` : ''}
        ${ownerAddr2 ? `<div style="text-align:center; font-size:0.875rem; color:#6b7280; font-weight:600; line-height:1.4;">${ownerAddr2}</div>` : ''}
      </div>

      <!-- APN and Size -->
      <div style="text-align:center; margin-bottom:1rem;">
        <div style="font-size:0.9375rem; color:#6b7280; font-weight:600; margin-bottom:0.375rem;">
          APN: ${apnText}
        </div>
        <div style="font-size:0.9375rem; color:#6b7280; font-weight:600;">
          Size: ${sizeText}
        </div>
      </div>

      <!-- All Details -->
      ${detailsRows.length > 0 ? `<div style="margin-bottom:1rem; font-size:0.875rem; text-align:center;">${detailsRows.join('')}</div>` : ''}

      <!-- Buttons -->
      <div style="display:flex; flex-direction:column; gap:0.625rem; margin-bottom:1rem;">
        <button id="${airtableBtnId}" style="background:#000000; color:white; border:none; border-radius:8px; padding:0.875rem 1rem; cursor:pointer; font-weight:600; font-size:0.9375rem; transition: background 0.2s;">
          <span style="color:#a78bfa; margin-right:0.5rem;">Gï¿½ï¿½</span>Add Parcel to Land Database
        </button>
        <button id="${landownerBtnId}" style="background:#000000; color:white; border:none; border-radius:8px; padding:0.875rem 1rem; cursor:pointer; font-weight:600; font-size:0.9375rem; transition: background 0.2s;">
          <span style="color:#a78bfa; margin-right:0.5rem;">Gï¿½ï¿½</span>Add Owner to Landowner Database
        </button>
      </div>

      <!-- Links -->
      ${(viewLink || countySearch) ? `<div style="text-align:center; display:flex; flex-direction:column; gap:0.5rem; padding-top:0.5rem; border-top:1px solid #e5e7eb;">${viewLink ? `<div>${viewLink}</div>` : ''}${countySearch ? `<div>${countySearch}</div>` : ''}</div>` : ''}
    </div>
  `;
}

// Create MVTLayer for vector tiles (low/medium zoom)
function createParcelsTileLayer() {
  return new MVTLayer({
    id: 'parcels-tiles',
    data: PARCELS_TILES_URL,
    pickable: true,
    getFillColor: [37, 99, 235, 38], // #2563eb with 15% opacity - matches GeoJsonLayer
    getLineColor: [30, 64, 175, 255], // #1e40af - matches GeoJsonLayer
    lineWidthMinPixels: 1,
    onClick: (info: any) => {
      if (!info?.object) return;
      const apn = info.object.properties?.apn;
      if (apn) {
        handlePick({ apn, coordinate: info.coordinate, props: info.object.properties });
      }
    }
  });
}

// Update deck.gl layers with parcel data
async function updateDeckLayers() {
  if (!deckOverlay || !map.value) {
    return;
  }

  // If parcels are disabled, clear layers
  if (!showParcels.value) {
    deckOverlay.setProps({ layers: [] });
    return;
  }

  // Check zoom level - only show parcels when zoomed in enough
  const zoom = map.value.getZoom() || 0;
  const MIN_PARCEL_ZOOM = 13; // Show parcels starting at zoom 13 (higher = need to zoom in more)

  if (zoom < MIN_PARCEL_ZOOM) {
    console.log(`Gï¿½ï¿½n+ï¿½ Zoom level ${zoom.toFixed(1)} too low. Zoom to ${MIN_PARCEL_ZOOM}+ to see parcels.`);
    deckOverlay.setProps({ layers: [] });
    return;
  }

  // Fetch live GeoJSON data from Supabase
  console.log(`Zoom ${zoom.toFixed(1)}: Fetching live GeoJSON data for entire viewport`);

  // Get current map bounds
  const bounds = map.value.getBounds();
  if (!bounds) return;

  const ne = bounds.getNorthEast();
  const sw = bounds.getSouthWest();

  try {
    console.log('Fetching parcels from Supabase for deck.gl...');
    const startTime = performance.now();

    // Call the parcels_in_bounds function using WKT bbox (existing RPC)
    const bbox = `POLYGON((${sw.lng()} ${sw.lat()}, ${ne.lng()} ${sw.lat()}, ${ne.lng()} ${ne.lat()}, ${sw.lng()} ${ne.lat()}, ${sw.lng()} ${sw.lat()}))`;

    // Use .limit() to get more parcels (Supabase default is 1000)
    // At zoomed out levels, we might have many parcels in view
    const { data, error } = await supabase
      .rpc('parcels_in_bounds', { bbox_wkt: bbox })
      .limit(10000); // Increase limit to handle large viewport areas

    if (error) {
      console.error('Error fetching parcels:', error);
      return;
    }

    const endTime = performance.now();
    console.log(`Gï¿½ï¿½ Fetched ${data?.length || 0} parcels in ${Math.round(endTime - startTime)}ms`);

    // Convert to GeoJSON FeatureCollection
    const features = (data || []).map((parcel: any) => {
      const geom = typeof parcel.geom === 'string' ? JSON.parse(parcel.geom) : parcel.geom;

      return {
        type: 'Feature',
        geometry: geom,
        properties: {
          id: parcel.id,
          apn: parcel.apn,
          address: parcel.address,
          city: parcel.city,
          county: parcel.county,
          zip_code: parcel.zip_code,
          owner_type: parcel.owner_type,
          size_acres: parcel.size_acres,
          property_url: parcel.property_url
        }
      };
    });

    const geojson = {
      type: 'FeatureCollection' as const,
      features
    };

    // Create GeoJsonLayer with unique ID based on timestamp to force refresh
    // This prevents "patchwork" effect from old parcel data lingering
    const parcelLayer = new GeoJsonLayer({
      id: `parcels-layer-${Date.now()}`,
      data: geojson as any,
      pickable: true,
      stroked: true,
      filled: true,
      getFillColor: [37, 99, 235, 38], // #2563eb with 15% opacity (38/255 = 0.15)
      getLineColor: [30, 64, 175, 255], // #1e40af
      getLineWidth: 2,
      lineWidthUnits: 'pixels', // Use 'pixels' for consistent line width
      onClick: (info: any) => {
        if (!info?.object) return;
        const { apn } = info.object.properties;
        handlePick({ apn, coordinate: info.coordinate, props: info.object.properties });
      }
    });

    // Update overlay with new layer (old layers are automatically removed)
    deckOverlay.setProps({ layers: [parcelLayer] });

  } catch (error) {
    console.error('Failed to update deck.gl GeoJSON layer:', error);
  }
}

// Clear all markers and polygons
function clearMarkers() {
  for (const m of markers) m.setMap(null);
  markers.length = 0;
  Object.keys(markersById).forEach(k => delete markersById[k]);
  Object.keys(infoWindowsById).forEach(k => delete infoWindowsById[k]);
}

function clearPolygons() {
  for (const p of polygons) p.setMap(null);
  polygons.length = 0;
  // Clear the APN tracking object
  for (const key in polygonsByApn) {
    delete polygonsByApn[key];
  }
}

// Geocode address
async function geocodeOne(addr: string): Promise<google.maps.LatLngLiteral | null> {
  if (!geocoder) return null;
  if (cache.has(addr)) return cache.get(addr)!;

  try {
    const result = await new Promise<google.maps.GeocoderResult[] | null>((resolve) => {
      geocoder!.geocode({ address: addr }, (results, status) => {
        if (status === google.maps.GeocoderStatus.OK && results && results.length) {
          resolve(results);
        } else {
          resolve(null);
        }
      });
    });

    const loc = result?.[0]?.geometry?.location;
    if (loc) {
      const p = { lat: loc.lat(), lng: loc.lng() };
      cache.set(addr, p);
      return p;
    }
  } catch (e) {
    console.warn('Geocode failed for', addr, e);
  }

  return null;
}

// Fetch parcels from Supabase with viewport filtering
async function fetchParcels(bounds?: google.maps.LatLngBounds): Promise<ParcelRow[]> {
  if (!showParcels.value) {
    console.log('Parcel layer is disabled');
    return [];
  }

  // Check zoom level - only show parcels when zoomed in enough
  const zoom = map.value?.getZoom() || 0;
  const MIN_ZOOM = 14; // Adjust this value (higher = need to zoom in more)

  if (zoom < MIN_ZOOM) {
    console.log(`Gï¿½ï¿½n+ï¿½ Zoom level ${zoom} too low. Zoom to ${MIN_ZOOM}+ to see parcels.`);
    return [];
  }

  try {
    const { fetchParcelsInBounds, fetchAllParcels } = await import('../lib/supabase');

    console.log('Fetching parcels from Supabase...');
    const startTime = performance.now();

    let parcels;

    // If we have bounds, use spatial filtering
    if (bounds) {
      console.log('Using viewport bounds to filter parcels...');
      parcels = await fetchParcelsInBounds(bounds);
    } else {
      // Fallback to all parcels (shouldn't happen often)
      console.log('No bounds available, fetching all parcels...');
      parcels = await fetchAllParcels(10000);
    }

    const endTime = performance.now();
    console.log(`Gï¿½ï¿½ Fetched ${parcels.length} parcels from Supabase in ${Math.round(endTime - startTime)}ms`);

    // Transform Supabase data to match our ParcelRow format
    return parcels.map(p => {
      // Parse the PostGIS geometry back to GeoJSON
      // Supabase returns geometry as GeoJSON object
      const geojson = p.geom ? (typeof p.geom === 'string' ? JSON.parse(p.geom) : p.geom) : null;

      return {
        id: p.id,
        apn: p.apn,
        address: p.address || null,
        city: p.city || null,
        zip_code: p.zip_code || null,
        county: p.county || 'Davis',
        owner_type: null,
        owner_name: p.owner_name || null,
        owner_address: p.owner_address || null,
        size_acres: p.size_acres || null,
        property_value: p.property_value || null,
        subdivision: p.subdivision || null,
        year_built: p.year_built || null,
        sqft: p.sqft || null,
        property_url: p.property_url || 'https://webportal.daviscountyutah.gov/App/PropertySearch/esri/map',
        geojson: geojson
      };
    }).filter(row => row.geojson != null);
  } catch (error) {
    console.error('Failed to fetch parcels from Supabase:', error);
    return [];
  }
}

// Calculate centroid of polygon for label placement
function calculateCentroid(paths: google.maps.LatLngLiteral[][]): google.maps.LatLngLiteral {
  // Use the first ring (outer boundary)
  const ring = paths[0];
  if (!ring || ring.length === 0) return { lat: 0, lng: 0 };

  let latSum = 0;
  let lngSum = 0;

  for (const point of ring) {
    latSum += point.lat;
    lngSum += point.lng;
  }

  return {
    lat: latSum / ring.length,
    lng: lngSum / ring.length
  };
}

// Clear county boundary polygons and labels
function clearCountyPolygons() {
  for (const p of countyPolygons) p.setMap(null);
  countyPolygons.length = 0;
  for (const label of countyLabels) { 
    (label as any).setMap(null); // OverlayView has setMap method
  }
  countyLabels.length = 0;
}

// Display county boundaries on map from Supabase
async function displayCountyBoundaries() {
  if (!map.value || !showCounties.value) return;

  clearCountyPolygons();

  try {
    const { fetchCounties } = await import('../lib/supabase');
    const counties = await fetchCounties();
    console.log(`Displaying ${counties.length} county boundaries from Supabase`);

    for (const county of counties) {
      const geojson = county.geom ? (typeof county.geom === 'string' ? JSON.parse(county.geom) : county.geom) : null;
      if (!geojson) continue;

      // Convert GeoJSON coordinates to Google Maps paths
      let paths: google.maps.LatLngLiteral[][] = [];

      if (geojson.type === 'Polygon') {
        paths = geojson.coordinates.map((ring: [number, number][]) =>
          ring.map(([lng, lat]) => ({ lat, lng }))
        );

